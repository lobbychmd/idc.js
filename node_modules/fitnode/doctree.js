/***********  根据表间关系构造树(json) 然后提供给 fitui.js 的 ajaxTree **********/

var doctree = function (db, config, extraData, expendNodes) {
    this.db = db;
    this.config = config;
    this.extraData = extraData;
    this.expendNodes = expendNodes;
    //console.log(expendNodes);
}

exports.doctree = doctree;

doctree.prototype = {
    constructor: doctree,
    middleware: {
        az: {
            dir: function (type, text, subtype, parent_attr, params) {
                var data = [];
                var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                for (c in letters) {
                    var l = { filter: (params && params.prefix ? params.prefix : "") + "[" + letters[c].toUpperCase() + letters[c].toLowerCase() + "]", text: letters[c], parent_type: type,
                        sub_type: subtype, middleware: 'az', nodeonly: true, id: 'az.' + subtype + "." + c
                    };
                    for (var i in parent_attr)
                        if (i && !l[i]) l[i] = parent_attr[i];
                    data.push(l);
                }
                return data;
            },
            children: function (_doctree, parent_attr) {
                var query = {};
                query[_doctree.config[parent_attr["sub_type"]].text] = eval('/^' + parent_attr['filter'] + '/');
                return [{ type: parent_attr['sub_type'], query: query}];
            }
        },
        summary: {
            dir: function (type, text, subtype, parent_attr) {
                return [{ text: text, type: type, sub_type: subtype, middleware: 'summary', nodeonly: true, id: 'summary.' + subtype}];
            },
            children: function (_doctree, parent_attr) {
                var query = {};

                return _doctree.config[parent_attr['sub_type']].children;
                //return [{ type: parent_attr['sub_type'], query: query}];
            }
        }
    },
    fillQuery: function (parent_attr, query) {
        var r = {};
        for (var q in query) {
            r[q] = query[q];
            if (typeof r[q] == "string") {
                var m = r[q].match(/\{([_\w]+)\}/i);
                if (m) r[q] = r[q].replace(m[0], parent_attr[m[1]]?parent_attr[m[1]]:this.extraData[m[1]]);
            }

        }
        console.log(r);
        return r;
    },
    get: function (attr, callback) {
        var type = attr['type'];
        var c = this.config[type];
        var children = c.children;
        if (attr['middleware']) {
            children = this.middleware[attr.middleware].children(this, attr);
        }

        var _doctree = this;
        new new require('./util.js').seq_asyncArray(
            function (item, params, callback) {
                if (item.middleware) {
                    var data = _doctree.middleware[item.middleware].dir(type, item.text, item.type, attr, item.params);
                    callback(params ? params.concat(data) : data);
                }
                else {
                    var data = [];
                    if (item.type) {
                        var cc = _doctree.config[item.type];
                        _doctree.db.collection(cc.table).find(_doctree.fillQuery(attr, item.query)).toArray(function (err, rows) {
                            for (var i in rows) {
                                var datarow = { text: rows[i][cc.text], type: item.type, table: cc.table, _id: rows[i]._id, id: rows[i]._id };
                                if (cc.fields) for (var j in cc.fields) datarow[cc.fields[j]] = rows[i][cc.fields[j]];
                                if (!cc.children) datarow["children"] = [];
                                data.push(datarow);
                            }
                            callback(params ? params.concat(data) : data);

                        });
                    }
                }
            },
            children,
            function (params) {
                //if (params) console.log(params)
                //递归调用
                if (params && (params.length > 0) && (_doctree.expendNodes)) {
                    new new require('./util.js').seq_asyncArray(
                        function (item1, params1, callback1) {
                            var ee = _doctree.expendNodes.indexOf(item1.id);
                            if (ee >= 0) {
                                _doctree.get(item1, function (children) {
                                    item1.children = children;
                                    callback1();
                                });
                            }
                            else callback1();
                        },
                        params,
                        function (params2) {
                            callback(params);
                        }
                    ).exec();
                } else callback(params);
            }
        ).exec();
    }
}